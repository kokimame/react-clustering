{"version":3,"sources":["ClusteringAlgorithms/Kmeans.js","ClusteringVisualizer/ClusteringVisualizer.js","App.js","index.js"],"names":["COLOR_PALLATE","get2dCentroid","cluster","xSum","ySum","forEach","point","length","get2dEuclidDistance","p1","p2","xd","yd","Math","sqrt","getKmeansClusteredPoints","points","K","N","centroids","Array","from","v","clusteredPoints","clusteredIndex","k","i","push","epoch","distanceArray","j","nearest","indexOf","min","newCentroids","colors","KmeansClustering","slice","WINDOW_WIDTH","window","innerWidth","WINDOW_HEIGHT","innerHeight","onresize","randomIntFromInterval","max","floor","random","ClusteringVisualizer","props","state","this","resetPoints","NUMBER_OF_POINTS","array","temp","shuffleArray","setState","currentPoints","document","getElementsByClassName","style","backgroundColor","className","map","value","idx","key","left","bottom","title","position","top","onClick","id","React","Component","App","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.f9b221ce.chunk.js","sourcesContent":["const COLOR_PALLATE = ['lightgreen', 'pink', 'orange'];\n\nfunction get2dCentroid(cluster) {\n    var xSum = 0, ySum = 0;\n    cluster.forEach(point => {\n        xSum += point[0];\n        ySum += point[1];\n    })\n    return [xSum / cluster.length, ySum / cluster.length];\n}\n\nfunction get2dEuclidDistance(p1, p2) {\n    var xd = p2[0] - p1[0];\n    var yd = p2[1] - p1[1];\n    xd *= xd;\n    yd *= yd;\n    return Math.sqrt(xd + yd);\n}\n\nexport function getKmeansClusteredPoints(points) {\n    const K = 2;\n    const auxillaryPoints = points.slice();\n    const colors = KmeansClustering(K, auxillaryPoints);\n\n    return colors;\n}\n\nfunction KmeansClustering(K, points) {\n    const N = points.length;\n    var centroids = Array.from({length: K}, v => 0);\n    var clusteredPoints = Array.from({length: K}, v => []);\n    var clusteredIndex = Array.from({length: K}, v => []);\n    // Initialize clusters\n    for (let k = 0; k < K; k++) {\n        for (let i = 0; i < N; i++) {\n            if (i % K === k) {\n                clusteredPoints[k].push(points[i]);\n            }\n        }\n        centroids[k] = get2dCentroid(clusteredPoints[k]);\n    }\n\n    for (let epoch = 0; epoch < 3; epoch++) {\n        clusteredPoints = Array.from({length: K}, v => []);\n        clusteredIndex = Array.from({length: K}, v => []);\n\n        for (let i = 0; i < N; i++) {\n            const distanceArray = Array.from(\n                {length: K}, (v, j) => get2dEuclidDistance(points[i], centroids[j])\n            )\n            const nearest = distanceArray.indexOf(Math.min(...distanceArray));\n            clusteredPoints[nearest].push(points[i]);\n            clusteredIndex[nearest].push(i)\n        }\n        const newCentroids = Array.from(\n            {length: K}, (v, k) => get2dCentroid(clusteredPoints[k])\n        );\n        centroids = newCentroids;\n    }\n\n    const colors = Array.from({length : points.length})\n    for (let k = 0; k < clusteredIndex.length; k++) {\n        for (let i = 0; i < clusteredIndex[k].length; i++) {\n            colors[clusteredIndex[k][i]] = COLOR_PALLATE[k];\n        }\n    }\n    return colors;\n}","import React from 'react';\nimport './ClusteringVisualizer.css'\nimport { getKmeansClusteredPoints } from '../ClusteringAlgorithms/Kmeans';\n\nlet WINDOW_WIDTH = window.innerWidth;\nlet WINDOW_HEIGHT = window.innerHeight;\nlet NUMBER_OF_POINTS = 100;\n\nfunction reportWindowSize() {\n    WINDOW_WIDTH = window.innerWidth;\n    WINDOW_HEIGHT = window.innerHeight;\n}\n\nfunction shuffleArray(array) {\n    for (var i = array.length - 1; i > 0; i--) {\n        var j = Math.floor(Math.random() * (i + 1));\n        var temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    return array;\n}\nwindow.onresize = reportWindowSize;\n\nconst PRIMARY_COLOR = 'turquoise';\nconst SECONDARY_COLOR = 'red';\nconst ANIMATION_SPEED_MS = 10;\n\nclass ClusteringVisualizer extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            points: []\n        }\n    }\n    componentDidMount() {\n        this.resetPoints();\n    }\n    resetPoints() {\n        var points = [];\n        for (let i = 0; i < NUMBER_OF_POINTS / 2; i++) {\n            points.push([\n                randomIntFromInterval(2*WINDOW_WIDTH/5, WINDOW_WIDTH),\n                randomIntFromInterval(2*WINDOW_HEIGHT/5, WINDOW_HEIGHT)\n            ])\n        }\n        for (let i = NUMBER_OF_POINTS / 2; i < NUMBER_OF_POINTS; i++) {\n            points.push([\n                randomIntFromInterval(0, 3*WINDOW_WIDTH/5),\n                randomIntFromInterval(0, 3*WINDOW_HEIGHT/5)\n            ])\n        }\n\n        points = shuffleArray(points);\n        this.setState({points: points});\n\n        const currentPoints = document.getElementsByClassName('a-point');\n        for (let i = 0; i < currentPoints.length; i++) {\n            const pointStyle = currentPoints[i].style;\n            pointStyle.backgroundColor = PRIMARY_COLOR;\n        }\n    }\n\n    KmeansClustering() {\n        const colors = getKmeansClusteredPoints(this.state.points);\n        const currentPoints = document.getElementsByClassName('a-point');\n\n        for (let i = 0; i < currentPoints.length; i++) {\n            const pointStyle = currentPoints[i].style;\n            pointStyle.backgroundColor = colors[i];\n        }\n    }\n    render() {\n        const points = this.state.points;\n        const TOTAL_BUTTONS = 5;\n        \n        return (\n            <>\n            <div className=\"points-container\">\n                {points.map((value, idx) => (\n                    <div\n                        className=\"a-point\"\n                        key={idx}\n                        style={{\n                            backgroundColor: PRIMARY_COLOR,\n                            left: `${value[0]}px`,\n                            bottom: `${value[1]}px`\n                        }}\n                    ></div>\n                ))}\n            </div>\n            <div className=\"buttons\" > \n                <button title=\"Generates a new random points\" \n                    style={{ position: 'relative',top:`${0*(WINDOW_HEIGHT-20)/TOTAL_BUTTONS}px`}} \n                    onClick={() => this.resetPoints()}>\n                    Generate New Points\n                </button>\n                <button title=\"K-means Clustering\" id=\"KmeansBtn\"\n                    style={{ position: 'relative', top:`${0.5*(WINDOW_HEIGHT-20)/TOTAL_BUTTONS}px`}} \n                    onClick={() => this.KmeansClustering()}>\n                    K-means Clustering\n                </button>\n                {/* <button title=\"Graph-based Clustering\" id=\"GraphBtn\"\n                    style={{ position: 'relative', top:`${1.5*(WINDOW_HEIGHT-20)/TOTAL_BUTTONS}px`}} \n                    onClick={() => {}}>\n                    Graph-based Clustering (Not yet)\n                </button> */}\n            </div>\n            </>\n        );\n    }\n}\n\nfunction randomIntFromInterval(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nexport default ClusteringVisualizer;","import React from 'react';\nimport ClusteringVisualizer from './ClusteringVisualizer/ClusteringVisualizer'\nimport './App.css'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <ClusteringVisualizer />\n    </div>\n  )\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <App />,\n  document.getElementById(\"root\")\n)"],"sourceRoot":""}